# 纸牌游戏开发文档

## 一、需求梳理

根据图片和文档要求，游戏需要实现以下功能：

### 1. 游戏区域划分

- **主牌区（Playfield）**：尺寸 1080 x 1500，显示需要消除的卡牌
- **堆牌区（Stack Area）**：尺寸 1080 x 580，包含：
  - 备用牌堆（Reserve Card Pile）：可以翻新牌
  - 底牌堆（Base Card Pile）：当前底牌显示区域

### 2. 核心功能需求

#### 需求1：卡牌匹配消除
- 点击主牌区的牌，如果与底牌点数差1，则可以匹配
- 匹配后，被点击的牌会平移到底牌位置并替换底牌
- 无花色限制

#### 需求2：翻备用牌
- 当主牌区无可匹配的牌时，可以从备用牌堆翻新牌
- 翻出的牌会成为新的底牌

#### 需求3：回退功能
- 点击回退按钮，可以撤销上一步操作
- 支持连续多次回退
- 卡牌会反着平移到原位置

### 3. 技术架构要求

- **开发环境**：Cocos Creator（原文档要求 cocos2dx 3.17，但使用 Cocos Creator 更现代）
- **架构模式**：MVC 架构
- **代码规范**：
  - 类名和文件名：大写字母开头
  - 函数名和变量名：驼峰风格（小写字母开头）
  - 私有成员：以下划线开头
  - 常量：以小写字母 k 开头

## 二、操作流程与步骤

### 步骤1：项目初始化

1. **创建 Cocos Creator 项目**
   - 打开 Cocos Creator
   - 选择"新建项目"
   - 选择 TypeScript 模板
   - 设置项目名称：`coco_poker`
   - 设置项目路径

2. **配置项目设置**
   - 打开"项目设置"
   - 设置设计分辨率为 1080 x 2080
   - 设置适配模式为"固定高度"

### 步骤2：创建目录结构

按照 MVC 架构创建以下目录：

```
assets/
├── scripts/
│   ├── configs/
│   │   ├── models/
│   │   └── loaders/
│   ├── models/
│   ├── views/
│   ├── controllers/
│   ├── managers/
│   ├── services/
│   ├── enums/
│   └── scenes/
└── resources/
    └── cards/  # 卡牌图片资源
```

### 步骤3：实现数据模型层

**文件**：`assets/scripts/models/CardModel.ts`

**原理**：
- 卡牌模型存储卡牌的所有数据：ID、点数、花色、位置、是否翻开、是否移除
- 支持序列化/反序列化，便于存档功能
- 提供 `getValue()` 方法获取卡牌数值，用于匹配判断

**为什么这样设计**：
- 数据与逻辑分离，模型只存储数据，不包含业务逻辑
- 序列化支持便于实现存档功能
- 使用类而不是接口，便于添加方法

### 步骤4：实现服务层

**文件**：`assets/scripts/services/CardMatchService.ts`

**原理**：
- 提供静态方法 `canMatch()` 判断两张牌是否可以匹配
- 匹配规则：点数差为1即可，无花色限制
- 提供 `hasMatchableCard()` 检查是否有可匹配的牌

**为什么这样设计**：
- 服务层无状态，不持有数据，便于复用
- 使用静态方法，无需实例化
- 业务逻辑集中管理，便于维护和测试

### 步骤5：实现视图层

**文件**：`assets/scripts/views/CardView.ts`

**原理**：
- 视图组件负责显示卡牌和接收用户输入
- 通过回调函数通知控制器，不直接处理业务逻辑
- 提供动画方法：`playMoveAnimation()`、`playFlipAnimation()`

**为什么这样设计**：
- 视图层只负责显示，符合单一职责原则
- 使用回调函数解耦，视图不依赖控制器
- 动画逻辑封装在视图层，便于复用

### 步骤6：实现控制器层

**文件**：`assets/scripts/controllers/GameController.ts`

**原理**：
- 控制器协调模型和视图
- 处理用户操作：点击卡牌、翻牌、回退
- 调用服务层进行业务逻辑判断
- 更新模型后通知视图更新

**为什么这样设计**：
- 控制器作为中间层，连接模型和视图
- 业务逻辑集中在控制器，便于维护
- 通过服务层处理具体业务，保持代码简洁

### 步骤7：实现回退管理器

**文件**：`assets/scripts/managers/UndoManager.ts`

**原理**：
- 使用栈结构存储回退记录
- 每次操作前记录完整状态
- 回退时从栈顶取出记录并恢复状态

**为什么使用栈**：
- 后进先出（LIFO）符合回退操作特性
- 支持连续多次回退
- 实现简单高效

**为什么作为 Manager 而不是 Service**：
- Manager 可以持有数据（回退栈）
- 作为 Controller 的成员，便于生命周期管理
- 禁止单例，避免全局状态污染

### 步骤8：创建游戏场景

1. **创建场景文件**
   - 在 `assets/scenes/` 创建 `GameScene.fire`
   - 设置场景大小为 1080 x 2080

2. **添加节点结构**
   ```
   GameScene
   ├── PlayfieldArea (主牌区容器)
   ├── StackArea (堆牌区容器)
   │   ├── ReserveStack (备用牌堆)
   │   └── BaseCardArea (底牌区域)
   └── UILayer (UI层)
       ├── UndoButton (回退按钮)
       └── ScoreLabel (分数标签)
   ```

3. **添加组件**
   - 在根节点添加 `GameScene` 脚本
   - 在对应节点添加相应的 View 组件
   - 配置组件引用

### 步骤9：配置资源

1. **准备卡牌图片**
   - 卡牌正面：52张（13点数 x 4花色）
   - 卡牌背面：1张
   - 格式：PNG，透明背景

2. **导入资源**
   - 将图片导入到 `assets/resources/cards/`
   - 在 Cocos Creator 中配置 SpriteFrame

3. **配置预制体**
   - 创建卡牌预制体 `CardPrefab`
   - 添加 `CardView` 组件
   - 配置 SpriteFrame 引用

## 三、代码原理详解

### 1. 卡牌匹配逻辑

**位置**：`CardMatchService.canMatch()`

```typescript
static canMatch(baseCard: CardModel, targetCard: CardModel): boolean {
    const baseValue = baseCard.getValue();
    const targetValue = targetCard.getValue();
    const diff = Math.abs(baseValue - targetValue);
    return diff === 1;
}
```

**原理**：
- 获取两张牌的点数值
- 计算绝对值差
- 如果差为1，则可以匹配

**为什么使用绝对值**：
- 支持两种情况：大1或小1
- 代码简洁，无需分别判断

### 2. 回退机制实现

**位置**：`UndoManager.undo()`

```typescript
public undo(gameModel: GameModel): boolean {
    if (this._undoStack.length === 0) return false;
    const undoRecord = this._undoStack.pop()!;
    return this._executeUndo(undoRecord, gameModel);
}
```

**原理**：
- 从栈中取出最后一条记录
- 根据操作类型执行相应的恢复逻辑
- 恢复卡牌位置、状态、底牌等

**为什么记录完整状态**：
- 确保回退的准确性
- 支持复杂的回退场景
- 便于扩展新的操作类型

### 3. 视图更新机制

**位置**：`GameController._updateCardViews()`

```typescript
private _updateCardViews(): void {
    this._gameModel.playfieldCards.forEach(card => {
        this.playfieldView.updateCardView(card.id);
    });
    // ... 更新其他视图
}
```

**原理**：
- 遍历所有卡牌模型
- 调用对应视图的更新方法
- 视图根据模型数据更新显示

**为什么这样更新**：
- 模型是数据源，视图是展示层
- 模型变化后统一更新视图，保证一致性
- 避免视图直接操作模型，保持单向数据流

### 4. 动画实现

**位置**：`CardView.playMoveAnimation()`

```typescript
public playMoveAnimation(targetPosition: Vec2, duration: number = 0.3, callback?: () => void): void {
    tween(this.node)
        .to(duration, { position: targetPosition })
        .call(() => {
            if (callback) callback();
        })
        .start();
}
```

**原理**：
- 使用 Cocos Creator 的 tween 系统
- 在指定时间内平滑移动到目标位置
- 动画完成后执行回调

**为什么使用 tween**：
- Cocos Creator 内置，性能好
- 支持链式调用，代码简洁
- 支持缓动函数，动画自然

## 四、常见问题解答

### Q1: 为什么使用 TypeScript 而不是 JavaScript？

**A**: 
- TypeScript 提供类型检查，减少运行时错误
- 更好的 IDE 支持，提高开发效率
- 代码更易维护和重构

### Q2: 为什么视图层不直接操作模型？

**A**:
- 保持单向数据流：Model -> Controller -> View
- 避免视图层包含业务逻辑
- 便于测试和维护

### Q3: 如何扩展新的游戏规则？

**A**:
1. 在 `CardMatchService` 中添加新的匹配规则
2. 在 `GameController` 中添加新的处理逻辑
3. 如需新的回退类型，在 `UndoManager` 中添加

### Q4: 如何优化性能？

**A**:
- 使用对象池管理卡牌节点
- 减少不必要的视图更新
- 使用事件系统替代频繁的回调

## 五、测试建议

### 单元测试

- 测试 `CardMatchService.canMatch()` 的各种情况
- 测试 `UndoManager` 的回退功能
- 测试模型序列化/反序列化

### 集成测试

- 测试完整的游戏流程
- 测试边界情况（无牌可匹配、备用牌用完等）
- 测试回退功能的连续性

### UI 测试

- 测试各种屏幕尺寸适配
- 测试动画流畅性
- 测试交互响应性

## 六、后续优化方向

1. **性能优化**
   - 对象池管理
   - 资源预加载
   - 减少 DrawCall

2. **功能扩展**
   - 音效和背景音乐
   - 粒子特效
   - 关卡系统
   - 成就系统

3. **用户体验**
   - 新手引导
   - 提示功能
   - 动画优化

