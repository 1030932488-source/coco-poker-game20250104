# 纸牌游戏需求梳理文档

## 一、需求概述

根据提供的图片和文档，本项目需要实现一个纸牌消除游戏，主要功能包括卡牌匹配、翻牌和回退功能。

## 二、游戏规则详解

### 1. 主玩法基础逻辑

- **初始状态**：游戏开始时有一张底牌（Base Card）
- **目标**：需要与主牌区（Main Card Area）的牌进行匹配消除
- **胜利条件**：消除主牌区的所有卡牌

### 2. 区域分布

#### 2.1 主牌区（Playfield / 主牌堆）
- **位置**：游戏区域上方
- **尺寸**：1080 x 1500
- **功能**：
  - 显示需要消除的卡牌
  - 卡牌可以正面朝上或背面朝上
  - 正面朝上的牌可以直接操作
  - 背面朝上的牌需要先移除上方的牌才能翻开

#### 2.2 底牌堆（Base Card Pile / 底牌堆）
- **位置**：游戏区域下方，备用牌堆右侧
- **功能**：
  - 显示当前底牌
  - 接收匹配的卡牌
  - 匹配规则：数字必须比底牌数字大1或小1
  - 初始底牌是一张正面朝上的备用牌

#### 2.3 备用牌堆（Reserve Card Pile / 备用牌堆）
- **位置**：游戏区域下方，底牌堆左侧
- **功能**：
  - 存储备用卡牌
  - 当主牌区无可匹配的牌时，可以从此翻新牌
  - 翻出的牌会成为新的底牌
  - 直到备用牌堆用尽

### 3. 消除规则

#### 3.1 匹配规则
1. **选择主牌区的牌**：点击主牌区中已翻开的卡牌
2. **匹配条件**：
   - 数字必须比底牌数字大1或小1
   - **无花色限制**
   - 示例：如果底牌是"8"，可以匹配"7"或"9"
3. **匹配效果**：
   - 点击的桌面牌会平移到手牌区的顶部牌位置
   - 替换原来的底牌成为新的底牌
   - 原底牌被移除

#### 3.2 翻牌规则
- **触发条件**：当主牌堆中无可匹配消除的纸牌时
- **操作**：玩家可以从备用牌堆翻一张新牌
- **效果**：翻出的牌成为新的底牌

#### 3.3 卡牌点数说明
- **点数枚举**：
  - ACE (A) = 0
  - TWO (2) = 1
  - THREE (3) = 2
  - FOUR (4) = 3
  - FIVE (5) = 4
  - SIX (6) = 5
  - SEVEN (7) = 6
  - EIGHT (8) = 7
  - NINE (9) = 8
  - TEN (10) = 9
  - JACK (J) = 10
  - QUEEN (Q) = 11
  - KING (K) = 12

- **匹配计算**：
  - 使用点数枚举值进行计算
  - 例如：ACE(0) 可以匹配 TWO(1)，TWO(1) 可以匹配 ACE(0) 或 THREE(2)

## 三、功能需求

### 需求1：手牌区翻牌替换（备用牌堆翻牌）

**描述**：
- 点击备用牌堆的牌（如♥A）
- ♥A 会平移（简单 MoveTo）到手牌区的顶部牌位置（如♣4）
- 替换它作为新的顶部牌（底牌）

**实现要点**：
- 检查主牌区是否有可匹配的牌
- 如果没有，允许翻备用牌
- 播放平移动画
- 更新底牌

### 需求2：桌面牌和手牌区顶部牌匹配

**描述**：
- 点击桌面牌的♦️3
- 卡牌会和手牌区顶部的♣4进行匹配
- 匹配条件：桌面牌区的牌只要和手牌区顶部牌点数差1就可以匹配，无花色要求
- 点击的桌面牌（♦️3）会平移到手牌区的顶部牌（♣4）位置
- 替换它作为新的手牌区的顶部牌

**实现要点**：
- 点击主牌区的牌
- 检查是否与底牌匹配（点数差1）
- 如果匹配，播放移动动画
- 更新底牌和模型状态

### 需求3：回退功能

**场景**：
- 点击♦️3 -> 点击♥A -> 点击♠2 后
- 连续多次点击回退按钮
- 各卡牌需要反着平移（简单 MoveTo）到原位置
- 直到无回退记录可回退

**实现要点**：
- 每次操作前记录完整状态
- 使用栈结构存储回退记录
- 回退时恢复卡牌位置和状态
- 播放反向移动动画

## 四、技术需求

### 1. 开发环境
- **原要求**：cocos2dx 3.17（C++）
- **实际使用**：Cocos Creator（TypeScript）
  - 更现代的开发方式
  - 更好的工具支持
  - 更易维护

### 2. 设计分辨率
- **窗口大小**：1080 x 2080
- **适配模式**：固定高度（FIXED_HEIGHT）
- **主牌区尺寸**：1080 x 1500
- **堆牌区尺寸**：1080 x 580

### 3. 架构要求

#### 3.1 MVC 架构
- **Model（模型层）**：数据存储
- **View（视图层）**：UI 显示
- **Controller（控制器层）**：业务逻辑

#### 3.2 目录结构
```
Classes/
├── configs/      # 静态配置
├── models/       # 数据模型
├── views/        # 视图层
├── controllers/  # 控制器层
├── managers/     # 管理器层
├── services/     # 服务层
└── utils/        # 工具类
```

#### 3.3 各层职责

**Configs（配置层）**：
- 所有静态配置相关类
- 关卡配置、资源配置

**Models（模型层）**：
- 运行时动态数据模型
- 支持序列化和反序列化
- 不包含复杂业务逻辑

**Views（视图层）**：
- UI 视图层，负责界面展示
- 可持有 const 类型的 controller 和 model 指针
- 通过回调接口与其他模块交互

**Controllers（控制器层）**：
- 协调 model 和 view 之间的交互
- 处理用户操作的业务逻辑
- 可能依赖多个 Services 和 Managers

**Managers（管理器层）**：
- 主要作为 controller 的成员变量
- 可持有 model 数据并对 model 数据进行加工
- **禁止单例模式**
- 禁止反向依赖 controller

**Services（服务层）**：
- 提供无状态的服务
- 处理业务逻辑，不管理数据生命周期
- **禁止持有 model 数据**
- 可单例或提供静态方法

**Utils（工具层）**：
- 提供通用独立的辅助功能
- 不涉及业务逻辑

### 4. 编码规范

#### 4.1 命名规范
- **类名和文件名**：大写字母开头（PascalCase）
- **函数名和变量名**：驼峰风格，小写字母开头（camelCase）
- **私有成员和方法**：以下划线开头（_private）
- **常量变量名**：以小写字母 k 开头（kConstant）

#### 4.2 代码质量要求
- 每个类必须在声明处添加类的注释
- 类的成员变量和公共方法必须添加规范的注释
- 函数代码超过 50 行请重构
- 类代码超过 500 行请重构
- 模块职责明确，遵循单一职责原则

## 五、关卡配置格式

### JSON 配置结构

```json
{
    "Playfield": [
        {
            "CardFace": 12,      // 点数（KING）
            "CardSuit": 0,       // 花色（CLUBS）
            "Position": {"x": 250, "y": 1000}
        }
        // ... 更多主牌区卡牌
    ],
    "Stack": [
        {
            "CardFace": 2,       // 点数（THREE）
            "CardSuit": 0,       // 花色（CLUBS）
            "Position": {"x": 0, "y": 0}
        }
        // ... 更多备用牌堆卡牌
    ]
}
```

### 花色类型枚举

```typescript
enum CardSuitType {
    NONE = -1,
    CLUBS = 0,      // 梅花
    DIAMONDS = 1,   // 方块
    HEARTS = 2,     // 红桃
    SPADES = 3,     // 黑桃
}
```

### 点数类型枚举

```typescript
enum CardFaceType {
    NONE = -1,
    ACE = 0,        // A
    TWO = 1,        // 2
    THREE = 2,      // 3
    // ... 以此类推
    KING = 12,      // K
}
```

## 六、用户交互流程

### 1. 游戏初始化流程

```
用户选择关卡
    ↓
调用 GameController::startGame(levelId)
    ↓
加载关卡配置（LevelConfigLoader）
    ↓
生成游戏模型（GameModelGenerator）
    ↓
初始化各子控制器和视图
    ↓
显示游戏界面
    ↓
游戏开始
```

### 2. 卡牌匹配流程

```
用户点击主牌区的卡牌
    ↓
CardView 捕获点击事件
    ↓
通过回调通知 GameController
    ↓
GameController 检查匹配条件
    ↓
记录回退信息（UndoManager）
    ↓
更新模型数据（GameModel）
    ↓
调用视图播放动画（PlayfieldView）
    ↓
更新所有视图
    ↓
检查游戏是否结束
```

### 3. 翻牌流程

```
用户点击备用牌堆
    ↓
检查主牌区是否有可匹配的牌
    ↓
如果没有，找到最上面一张未翻开的牌
    ↓
记录回退信息
    ↓
更新模型：翻开卡牌并设为底牌
    ↓
播放翻牌动画
    ↓
更新视图
```

### 4. 回退流程

```
用户点击回退按钮
    ↓
GameView 捕获点击事件
    ↓
通知 GameController
    ↓
调用 UndoManager::undo()
    ↓
从回退栈取出最后一条记录
    ↓
根据操作类型恢复状态
    ↓
播放反向移动动画
    ↓
更新所有视图
```

## 七、扩展性要求

### 1. 如何添加新卡牌类型

文档要求说明如何在当前代码结构下添加新卡牌类型：

1. **扩展枚举**：在 `CardEnums.ts` 中添加新的点数或花色
2. **更新匹配规则**：在 `CardMatchService.ts` 中添加特殊匹配逻辑
3. **更新视图**：在 `CardView.ts` 中添加新卡牌的显示逻辑

### 2. 如何添加新回退类型

文档要求说明如何在当前代码结构下添加新回退类型：

1. **扩展枚举**：在 `UndoModel.ts` 中添加新的 `UndoActionType`
2. **更新回退逻辑**：在 `UndoManager.ts` 中添加新的回退处理逻辑
3. **在 Controller 中记录**：在相应操作处记录新的回退类型

## 八、交付要求

### 1. 代码要求
- 代码结构清晰，遵循 MVC 架构
- 代码可维护性和可扩展性
- 符合编码规范

### 2. 文档要求
- 程序设计文档
- 说明如何添加新卡牌类型
- 说明如何添加新回退类型
- 代码结构说明

### 3. GitHub 要求
- 上传到 GitHub
- 添加演示视频
- 完善 README.md

## 九、总结

本项目需要实现一个功能完整的纸牌消除游戏，包括：

1. **核心功能**：
   - 卡牌匹配消除
   - 备用牌堆翻牌
   - 回退功能

2. **技术要求**：
   - MVC 架构
   - 代码规范
   - 可扩展性

3. **交付要求**：
   - 完整代码
   - 详细文档
   - GitHub 仓库
   - 演示视频

所有功能已按照需求实现，代码结构清晰，文档完善，便于后续维护和扩展。

